<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法笔记上机指南-入门模拟-1</title>
      <link href="/2019/08/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E4%B8%8A%E6%9C%BA%E6%8C%87%E5%8D%97-%E5%85%A5%E9%97%A8%E6%A8%A1%E6%8B%9F-1/"/>
      <url>/2019/08/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E4%B8%8A%E6%9C%BA%E6%8C%87%E5%8D%97-%E5%85%A5%E9%97%A8%E6%A8%A1%E6%8B%9F-1/</url>
      
        <content type="html"><![CDATA[<p>涉及的内容有： </p><ul><li><p>简单模拟 ✔</p></li><li><p>查找元素 ✔</p></li><li><p>图形输出 ✔</p></li><li><p>日期处理 ✔</p></li><li><p>进制转换 ✔</p></li><li><p>字符串处理 </p><p><strong>PTA网址：</strong><a href="https://pintia.cn/problem-sets/994805260223102976/problems/type/7" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805260223102976/problems/type/7</a></p><p><strong>Basic 1001 1011 1016 1026 1046 1008 1012 1018</strong></p></li></ul><a id="more"></a><hr><h2 id="简单模拟"><a href="#简单模拟" class="headerlink" title="简单模拟"></a>简单模拟</h2><blockquote><p><strong>1001 害死人不偿命的(3n+1)猜想</strong> </p></blockquote><p><strong>分析：</strong> 奇数就乘三加一，偶数就除以二，直到N为1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> N, cnt = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line"><span class="keyword">while</span>(N != <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(N % <span class="number">2</span> == <span class="number">1</span>) N =  (N * <span class="number">3</span> + <span class="number">1</span>) / <span class="number">2</span> ;</span><br><span class="line"><span class="keyword">else</span> N = N / <span class="number">2</span>;</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; cnt;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>1011</strong> <strong>A+B 和 C</strong> </p></blockquote><p><strong>分析</strong>： 由于可能存在A+B之后大于int的最大范围，应该让<strong>A+B的和C设定为longlong类型</strong>，然后相加比较就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> A, B, C;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld %lld %lld"</span>,&amp;A, &amp;B, &amp;C);</span><br><span class="line"><span class="keyword">if</span>(A + B &gt; C) <span class="built_in">printf</span>(<span class="string">"Case #%d: true\n"</span>, i+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Case #%d: flase\n"</span>, i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>B1016 部分A + B</strong></p></blockquote><p><strong>分析</strong>：根据题意A，B的最大范围超过了int，所以也应该用long long类型 ，然后在while循环里分别判断A,B里分别有多少个DA和DB，判断方法从末位往前一个个判断即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> A, B, ansA = <span class="number">0</span>, ansB = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">int</span> DA, DB;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld %d %lld %d"</span>,&amp;A, &amp;DA, &amp;B, &amp;DB);</span><br><span class="line"><span class="keyword">while</span>(A != <span class="number">0</span> || B != <span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(A % <span class="number">10</span> == DA) ansA = ansA * <span class="number">10</span> + DA;</span><br><span class="line"><span class="keyword">if</span>(B % <span class="number">10</span> == DB) ansB = ansB * <span class="number">10</span> + DB;</span><br><span class="line">A /= <span class="number">10</span>;</span><br><span class="line">B /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ansA + ansB);</span><br><span class="line">    reuturn <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>*<em>B1026 程序运行时间 *</em> </p></blockquote><p><strong>分析</strong>：在时间问题中，由于60秒等于一分钟，六十分钟等于一小时，所以是可以用<strong>进制转换</strong>的思路来得到时分秒的，当然因为想要得到<strong>时</strong>，<strong>分</strong>，<strong>秒</strong> 这仅仅三位数字也是可以利用常识直接运算得出，需要注意的是题目还要求<strong>四舍五入</strong>，所以应当采用一定的办法满足题目要求，还有容易错的一个地方是当时分秒为个位数时要补0，如<strong>02:03:09</strong>。</p><p>由于进制转换的思路比较具有普适性，所以我就先用它啦~</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> C1, C2, time;</span><br><span class="line"><span class="keyword">int</span> hh, mm, ss;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;C1,&amp;C2);</span><br><span class="line">time = (C2 - C1 + <span class="number">50</span>) / <span class="number">100</span>; <span class="comment">//对秒进行四舍五入</span></span><br><span class="line">ss = time % <span class="number">60</span>; <span class="comment">//对“秒位”取余获得秒</span></span><br><span class="line">time /= <span class="number">60</span>; <span class="comment">//做除法之后的time表示的是以分为单位</span></span><br><span class="line">mm = time % <span class="number">60</span>;<span class="comment">//对“分位”取余获得分钟</span></span><br><span class="line">time /= <span class="number">60</span>;<span class="comment">//做除法之后的time表示的是以时为单位</span></span><br><span class="line">hh = time;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%02d:%02d:%02d"</span>,hh,mm,ss);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是简单版</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> C1, C2, time;</span><br><span class="line"><span class="keyword">int</span> hh, mm, ss;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;C1,&amp;C2);</span><br><span class="line">time = (C2 - C1 + <span class="number">50</span>) / <span class="number">100</span>; <span class="comment">//对秒进行四舍五入</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%02d:%02d:%02d"</span>,time / <span class="number">3600</span>,(time % <span class="number">3600</span>) / <span class="number">60</span>,time % <span class="number">60</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>B1046</strong>  <strong>划拳</strong></p></blockquote><p><strong>分析：</strong>注意两个人都赢和两个人都输是“不算数“的，让他们继续往下比就可以啦！~</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);</span><br><span class="line"><span class="keyword">int</span> J1, J2, Y1, Y2;</span><br><span class="line"><span class="keyword">int</span> Jfail = <span class="number">0</span>, Yfial = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>,&amp;J1, &amp;J2, &amp;Y1, &amp;Y2);</span><br><span class="line"><span class="keyword">if</span>(J1 + Y1 == J2 &amp;&amp; J1 + Y1 != Y2) Yfial++; <span class="comment">//乙输</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(J1 + Y1 == Y2 &amp;&amp; J1 + Y1 != J2) Jfail++; <span class="comment">//甲输</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, Jfail ,Yfial);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>B1008 数组元素循环右移问题</strong></p></blockquote><p><strong>分析：</strong> 这一题需要注意的是题目所给的右移多少位置M，是有可能大于数组个数N的，且因为数组为N个元素向右移动N个得到的数组使它本身，所以在进行实际处理之前应该让 <strong>M % N 取余对M进行修正</strong>得到具有”实际“移动效果的M。完成这题的思路并不唯一，下面是两种方法。</p><p>①倒置法</p><p>  由于有reverse逆置函数可以使用，所以就可以很方便的完成右移问题！</p><p><img src="/2019/08/02/算法笔记上机指南-入门模拟-1/1.jpg" alt="1"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> N , M;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; temp; </span><br><span class="line">v.push_back(temp);</span><br><span class="line">&#125;</span><br><span class="line">M = M % N;</span><br><span class="line">    <span class="comment">//逆置</span></span><br><span class="line">reverse(v.begin(),v.end());</span><br><span class="line">reverse(v.begin(),v.begin() + M);</span><br><span class="line">reverse(v.begin() + M ,v.end());</span><br><span class="line">    <span class="comment">//输出👇</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v[i] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>② 按位输出</p><p>先输出从index为第n - m 到 n -1的位置，再输出index从0到n - m - 1的位置，也就是先输出右移的那些数字后，再输出剩下的数字来模拟倒置的一个效果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">110</span>];</span><br><span class="line">    <span class="keyword">int</span> n, m, count = <span class="number">0</span>;<span class="comment">//count控制输出空格</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    m %= n;<span class="comment">//修正</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    <span class="comment">//输出👇</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - m; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,a[i]);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count &lt; n)<span class="built_in">printf</span> (<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n - m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,a[i]);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count &lt; n) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>B1012 数字分类</strong></p></blockquote><p><strong>思路：</strong> ①利用hash散列将各个输入的数字进行归类在进行处理，这里的散列函数是 *<em>除留取余法 H(key) = key % mod *</em>，</p><p>注意这里给的是一系列的<strong>正整数</strong>，不存在 0 的情况 ，还有某些数字类别不存在，要输出”<strong>N</strong>“</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> N,temp,max = <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> A1 = <span class="number">0</span>, A2 = <span class="number">0</span>, A3 = <span class="number">0</span>, A5 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> A4 = <span class="number">0.0</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">v[temp % <span class="number">5</span>].push_back(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始输入👆</span></span><br><span class="line"><span class="comment">//处理</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ;j &lt; v[i].size();j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; v[<span class="number">0</span>][j] % <span class="number">2</span> == <span class="number">0</span>)  A1 += v[i][j];</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">1</span> &amp;&amp; j % <span class="number">2</span> == <span class="number">0</span>) A2 += v[i][j];</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">1</span> &amp;&amp; j % <span class="number">2</span> == <span class="number">1</span>) A2 -= v[i][j];</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">2</span>) A3 = v[<span class="number">2</span>].size();</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">3</span>) A4 += (<span class="keyword">double</span>)v[i][j] / v[i].size();</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">4</span> &amp;&amp; v[i][j] &gt; A5) A5 = v[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出👇</span></span><br><span class="line"><span class="keyword">if</span>(A1 == <span class="number">0</span>)) <span class="built_in">printf</span>(<span class="string">"N "</span>); <span class="comment">//if(v[0].size() == 0 || (v[0].size() != 0 &amp;&amp; A1 == 0))也可以</span></span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d "</span>,A1);</span><br><span class="line"><span class="keyword">if</span>(v[<span class="number">1</span>].size() == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"N "</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d "</span>,A2);</span><br><span class="line"><span class="keyword">if</span>(v[<span class="number">2</span>].size() == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"N "</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d "</span>,A3);</span><br><span class="line"><span class="keyword">if</span>(v[<span class="number">3</span>].size() == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"N "</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%.1f "</span>,A4);</span><br><span class="line"><span class="keyword">if</span>(v[<span class="number">4</span>].size() == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"N"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d"</span>,A5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②当然了，也有不用vector的办法，可以直接利用两个数组<strong>count[5]</strong>和<strong>ans[5]</strong>，一个存储五类数字的个数，一类存储五类数字的输出结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> ans[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n, temp;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp);</span><br><span class="line">        <span class="keyword">if</span>(temp % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(temp % <span class="number">2</span> == <span class="number">0</span>) ans[<span class="number">0</span>] += temp;</span><br><span class="line">            count[<span class="number">0</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(temp % <span class="number">5</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(count[<span class="number">1</span>] % <span class="number">2</span> == <span class="number">0</span>) ans[<span class="number">1</span>] += temp;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(count[<span class="number">1</span>] % <span class="number">2</span> == <span class="number">1</span>) ans[<span class="number">1</span>] -= temp;</span><br><span class="line">            count[<span class="number">1</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(temp % <span class="number">5</span> == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            count[<span class="number">2</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">else</span>  <span class="keyword">if</span>(temp % <span class="number">5</span> == <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[<span class="number">3</span>] += temp;</span><br><span class="line">            count[<span class="number">3</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(temp % <span class="number">5</span> == <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(temp &gt; ans[<span class="number">4</span>]) ans[<span class="number">4</span>] = temp;</span><br><span class="line">            count[<span class="number">4</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输入👆</span></span><br><span class="line">    <span class="comment">//输出👇</span></span><br><span class="line">    <span class="keyword">if</span>(ans[<span class="number">0</span>] == <span class="number">0</span>) <span class="built_in">printf</span> (<span class="string">"N "</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d "</span>,ans[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span>(count[<span class="number">1</span>] == <span class="number">0</span>) <span class="built_in">printf</span> (<span class="string">"N "</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d "</span>,ans[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(count[<span class="number">2</span>] == <span class="number">0</span>) <span class="built_in">printf</span> (<span class="string">"N "</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d "</span>,count[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">if</span>(count[<span class="number">3</span>] == <span class="number">0</span>) <span class="built_in">printf</span> (<span class="string">"N "</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%.1f "</span>,(<span class="keyword">double</span>)ans[<span class="number">3</span>] / count[<span class="number">3</span>]);</span><br><span class="line">    <span class="keyword">if</span>(count[<span class="number">4</span>] == <span class="number">0</span>) <span class="built_in">printf</span> (<span class="string">"N"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans[<span class="number">4</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 学习 </tag>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归</title>
      <link href="/2019/07/29/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5-part3-x/"/>
      <url>/2019/07/29/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5-part3-x/</url>
      
        <content type="html"><![CDATA[<p>本章涉及的内容有： </p><ul><li><p>排序 </p></li><li><p>散列 </p></li><li><p>递归 ✔</p><ul><li>分治与递归 ✔</li><li>全排列问题 ✔</li><li>n皇后问题 ✔</li></ul></li><li><p>贪心</p></li><li><p>二分</p></li><li><p>Two Pointers</p></li><li><p>其他高效技巧与算法</p><p>**注：由于这本书的大部分例题都会以PAT呈现，所以我还会附上柳婼的解答，因为她的解答会更清爽一些！也很好理解！并且课本的代码会按自己喜好改动，并非完全一致</p></li></ul><a id="more"></a><h1 id="递归-4-3"><a href="#递归-4-3" class="headerlink" title="递归 4.3"></a>递归 4.3</h1><blockquote><p>分治</p></blockquote><p>​        分治的全称为“分而治之”，也就是说，<strong>分治法将原问题划分成若干个规模较小而结构与原问题相同或相似的子问题，然后分别解决这些子问题，最后合并子问题的解，即可得到原问题的解。</strong> </p><p>​        ①分解：将原问题分解为若干和原问题拥有相同或相似结构的子问题。</p><p>​        ②解决：递归求解所有子问题，如果存在子问题的规模小到可以直接解决，就直接解决它。</p><p>​        ③合并：将所有子问题的解合并为原问题的解。        </p><p><em>需要指出的是，分治法分解出的子问题应当是<strong>相互独立，没有交叉</strong>的</em></p><p>​        其中，一般把分解的子问题个数为1的情况称为<strong>减治</strong>，把子问题大于1的情况称为分治，例如对n求阶乘体现了减治，对Fibonacci数列的求解则体现了分治的思想。</p><p><em>（分治是一种算法思想，它除了可以用递归手段实现，也可以用非递归手段实现）</em></p><blockquote><p>递归</p></blockquote><p>​        递归的实现就在于<strong>反复调用和自身函数同名的函数</strong>，并且在调用自身函数的同时，问题的范围得到一定的缩小（分解），直到分解到可以直接得出结果的边界，在边界问题得到解决后函数会通过返回，将所有已经解决的小边界问题合并，得出最终的答案。</p><hr><p>​        <strong>递归逻辑中最重要的两个概念</strong></p><p>​        <strong>①递归式</strong>（存在可以使问题不断分解的手段）</p><p>​        <strong>②递归边界</strong> （问题缩小到边界后可以得出的结论）</p><p>​        既如果需要使用递归的方法解决问题，则一定需要有可以将原问题分解为若干小问题的手段（递归式）和分解的尽头（递归边界）。</p><hr><p>​        下面以求n阶乘为例</p><p>​        由 n！ = 1 * 2 * 3····· * n  可以不难得到它的递推形式 n ！ = n * (n - 1) * (n - 2) * ······* 2 * 1。所以如果使用F(n)来表示n！，可以得到F(n) = F(n - 1)  * n 的<strong>递归式</strong>，这样问题的规模就逐渐缩小了。</p><p>​        在F(n)规模缩小为F(n - 1)后，又可以将F(n - 1) 缩小为 F(n - 2)，那么它的尽头就是F(0)的时候，且我们可以直接得出 0！= 1 ，所以F(0)就是<strong>递归边界</strong></p><p>​        在得到递归式和递归边界之后就可以用代码实现了 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">F</span> <span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//递归边界</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> F(n<span class="number">-1</span>) * n; <span class="comment">//递归式</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,F(n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>递归的详细过程</em></p><p>①假设 n 的值为3</p><p>②进入F(3)函数，判断(n == 0)不成立，返回F(2) * 3 ；F(2)还未知，程序会调用F(2)求它的值；</p><p>③进入F(2)函数，判断(n == 0)不成立，返回F(1) * 2 ；F(1)还未知，程序会调用F(1)求它的值；</p><p>④进入F(1)函数，判断(n == 0)不成立，返回F(0) * 1 ；F(0)还未知，程序会调用F(2)求它的值；</p><p>⑤进入F(0)函数，判断(n == 0)成立，返回 1；</p><p>由于F(1)等到了F(0)的值，将返回F(0) * 1 既 1 * 1 = 1;</p><p>由于F(2)等到了F(1)的值，将返回F(1) * 2 既 1 * 2 = 2；</p><p>由于F(3)等到了F(2)的值，将返回F(2)  * 3 既 2 * 3 = 6；</p><p>所以F(3) = 6；</p><p>​        <strong>Fibonacci数列</strong>也是类似的</p><p>​        递归式 F(n) = F(n - 1) + F(n - 2)</p><p>​        递归边界 F(0) = 1 和 F(1) = 1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">F</span> <span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">0</span> || n == <span class="number">1</span> ) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> F(n - <span class="number">1</span>) + F(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,F(n));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>全排列问题</strong></p></blockquote><p>​        全排列就是指由n个整数能形成的所有排列。</p><p>​        对1,2,3这三个整数来说，（1，2，3）（1，3，2）（2，1，3）（2，3，1）（3，1，2）（3，2，1）就是这三个整数按字典序从小到大的顺序的全排列。</p><p>​        若我们要排列 1~n 这n个数全排列，从递归的角度思考则把问题分解为求“以1开头的全排列”，“以2开头的全排列”，“以3开头的全排列“·····，然后对他们进行再一次分解求 “以1，2开头的全排列”，“以1，3开头的全排列”·····，以此类推，直到只剩下一个数为止。</p><p>​        所以我们就不难总结出利用递归解决全排列问题的<strong>递归式</strong>和<strong>递归边界</strong></p><p>​        <strong>下面是求1~4四个数字为例的全排列过程图</strong></p><p><img src="/2019/07/29/算法笔记-第四章-算法初步-part3-x/1.jpg" alt="1"></p><blockquote><blockquote><p>递归实现1~N全排列</p></blockquote></blockquote><p>​        实现细节：</p><p>​        ①设定数组 <strong>P</strong> （index = 1~ n）存放当前的排列，在设定一个散列数组 <strong>HashTable</strong> ，若由一个数字<strong>X</strong>（1≤X≤n）已经排进数组P中，则让HashTable[X] = true</p><p>​        ②利用for循环从数组P的第一个位置开始填入X，填入后把HashTable[X]设为true，然后进行递归处理下一个位置（由于X已经被排进数组P中，HashTable[X]为true，所以在填入下一个位置时会跳过X，以免填入同样的数字），当递归完成时，再将HashTable[x] = false，以便开始在本位置填充其他数字</p><p>​        ③<strong>递归边界</strong>就是当要填入P的位置（index）等于n+1时，既P数组内所有的位置都被填满了，这个时候就进行输出就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面的课本实现的代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">11</span>;</span><br><span class="line"><span class="comment">//P为当前排列,HashTable记录整数x是否已经被排入P中</span></span><br><span class="line"><span class="keyword">int</span> n, P[maxn],hashtable[maxn] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理当前的排列中的第index位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateP</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index == n + <span class="number">1</span>)<span class="comment">// 递归边界（既P内的所有位置已经被填满）</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=n; i++) <span class="comment">//输出当前的排列</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,P[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n;x++) <span class="comment">//从第一个位置开始依次往P[index]中填入数字</span></span><br><span class="line">    <span class="keyword">if</span>(hashtable[x] == <span class="literal">false</span>) <span class="comment">//当前的x的值还未参与排列</span></span><br><span class="line">    &#123;</span><br><span class="line">        P[index] = x;<span class="comment">//将当前x的值填入排列的第index个位置</span></span><br><span class="line">        hashTable[x] = <span class="literal">true</span>;<span class="comment">//将hash值设为true表示该x值已经在排列之中</span></span><br><span class="line">        generateP(index + <span class="number">1</span>); <span class="comment">//调用同名函数处理排列的下一个位置</span></span><br><span class="line">        hashTable[x] = <span class="literal">false</span>; <span class="comment">/*已处理完P[index]位置上为x的所有子问题，既处理完了P[index]位置上以x开头的所有全排列，之后将x的hash值重设为false是为了在P[index]上填入其他数字，得到在P[index] 位置以x+1，x+2·····开头的所有全排列*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="number">4</span>;<span class="comment">//输出1~4的全排列</span></span><br><span class="line">    generateP(<span class="number">1</span>);<span class="comment">//从P[1]开始填入数字</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>n皇后问题</strong></p></blockquote><p>​        n皇后问题指的是在一个 n * n的国际象棋盘上放置 n个皇后后，使得这n个皇后两两均不在同一行，不在同一列，不在同一对角线上，求合法的方案书。</p><p>​        <strong><em>例子：五个皇后</em></strong></p><p><img src="/2019/07/29/算法笔记-第四章-算法初步-part3-x/2.png" alt="2"></p><p>​        解决n皇后问题有很多方法，最暴力的方法是<strong>从n^2中选择n个位置</strong> 再从中选择满足条件的情况，那么将会有 C n^2取n （C是组合数）的枚举量，当n = 8 时，枚举量高达 54,502,232,这是无法承受的…  </p><p>​        由于每行只能放一个皇后，每一列也只能放一个皇后，如果把n列皇后所在的行号依次写出，那么会发现其实就是求就行号<strong>1~n全排列！</strong> 由于一共只有n！个排列，所以总共的枚举量在n = 8的时候只需要 40320 次，相比第一种方法会优效许多</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面是全排列求解n皇后问题的代码</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateP</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index == n+<span class="number">1</span>)<span class="comment">//递归边界</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>; <span class="comment">//flag为true时表示当前排列合法，这里先假设是合法的,再进行检验</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++) <span class="comment">//遍历任意两个皇后</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(i - j) == <span class="built_in">abs</span>(P[i] - P[j])) <span class="comment">/*由于在一条对角线上的皇后具有对称性，因此两个皇后他们的行号和列号是对称的，所以两个皇后如果在一条对角线上则会满足该语句*/</span></span><br><span class="line">                 flag = <span class="literal">false</span>;<span class="comment">//不合法</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="literal">true</span>) count++;<span class="comment">//方案合法则令count+1；</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>;x &lt;= n;x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(hashTable[x] == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            P[index] = x;</span><br><span class="line">            hashTable[x] = <span class="literal">true</span>;</span><br><span class="line">            generateP(index + <span class="number">1</span>); <span class="comment">//递归式</span></span><br><span class="line">            hashTable[x] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        虽然这一种做法比第一种做法好许多，但是仔细思考可以发现，如果我们在放置前几个皇后之后，后面的几个皇后不管怎么放置都会是不合法的话，那么其实是没有必要继续往下继续递归的(例如上图中不合法的情况，既我们放置了351的皇后，那么后两个皇后不管怎么放置都会是不合法的)直接返回上层即可，这样一来我们又可以缩减计算量，下面我们就来试试吧！</p><p>​        <strong>实现思路</strong>：在每放置一个新的皇后之后，都跟前面的皇后进行比较看是否会合法，不合法就break，合法就进行放置，并且递归进入下一个位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateP</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index == n + <span class="number">1</span>) <span class="comment">//递归边界</span></span><br><span class="line">    &#123;</span><br><span class="line">        count++; <span class="comment">// 能到达这里的都是合法排列</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n;x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(hashTable[x] == <span class="literal">false</span>)  <span class="comment">//第x行还没有皇后</span></span><br><span class="line">        &#123;</span><br><span class="line">  <span class="keyword">bool</span> flag = <span class="literal">true</span>; <span class="comment">//flag为true表示当前行的位置合法，这里先暂时假设为合法的，再进行检验</span></span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> pre = <span class="number">1</span>; pre &lt; index; pre++) <span class="comment">//遍历之前放置好的皇后</span></span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="comment">//第index列的皇后行号为x，第pre列的皇后行号为P[pre]</span></span><br><span class="line">                 <span class="keyword">if</span>(<span class="built_in">abs</span>(index - pre) == <span class="built_in">abs</span>(x - P[pre])) <span class="comment">//在同一对角线</span></span><br><span class="line">                 &#123;</span><br><span class="line">                     flag = <span class="literal">false</span>; <span class="comment">//冲突 </span></span><br><span class="line">                     <span class="keyword">break</span>; </span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="literal">true</span>) <span class="comment">// 如果在第x行的皇后是合法的 </span></span><br><span class="line">            &#123;</span><br><span class="line">                P[index] = x; <span class="comment">//把第index列皇后放在在x行</span></span><br><span class="line">                hashTable[x] = <span class="literal">true</span>; <span class="comment">//第x行已被占用</span></span><br><span class="line">                generateP(index + <span class="number">1</span>);<span class="comment">//递归处理下一列的皇后</span></span><br><span class="line">                hashTable[x] = <span class="literal">false</span>;<span class="comment">//递归完毕，返回第x行为未占用状态</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        我们把由于一些事实导致的已经不需要往任何一个子问题进行递归，而直接返回上一层的动作称为<strong>回溯法</strong>，</p><p>上面的例子就是采用回溯写法来解决n皇后问题。</p><hr><p>嘻嘻，推翻了万恶的n皇后 耶耶耶~</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 算法笔记 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归</title>
      <link href="/2019/07/29/%E9%80%92%E5%BD%92/"/>
      <url>/2019/07/29/%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<p>本章涉及的内容有： </p><ul><li><p>排序 </p></li><li><p>散列 </p></li><li><p>递归 ✔</p><ul><li>分治与递归 ✔</li><li>全排列问题 ✔</li><li>n皇后问题 ✔</li></ul></li><li><p>贪心</p></li><li><p>二分</p></li><li><p>Two Pointers</p></li><li><p>其他高效技巧与算法</p><p>**注：由于这本书的大部分例题都会以PAT呈现，所以我还会附上柳婼的解答，因为她的解答会更清爽一些！也很好理解！并且课本的代码会按自己喜好改动，并非完全一致</p></li></ul><a id="more"></a><h1 id="递归-4-3"><a href="#递归-4-3" class="headerlink" title="递归 4.3"></a>递归 4.3</h1><blockquote><p>分治</p></blockquote><p>​        分治的全称为“分而治之”，也就是说，<strong>分治法将原问题划分成若干个规模较小而结构与原问题相同或相似的子问题，然后分别解决这些子问题，最后合并子问题的解，即可得到原问题的解。</strong> </p><p>​        ①分解：将原问题分解为若干和原问题拥有相同或相似结构的子问题。</p><p>​        ②解决：递归求解所有子问题，如果存在子问题的规模小到可以直接解决，就直接解决它。</p><p>​        ③合并：将所有子问题的解合并为原问题的解。        </p><p><em>需要指出的是，分治法分解出的子问题应当是<strong>相互独立，没有交叉</strong>的</em></p><p>​        其中，一般把分解的子问题个数为1的情况称为<strong>减治</strong>，把子问题大于1的情况称为分治，例如对n求阶乘体现了减治，对Fibonacci数列的求解则体现了分治的思想。</p><p><em>（分治是一种算法思想，它除了可以用递归手段实现，也可以用非递归手段实现）</em></p><blockquote><p>递归</p></blockquote><p>​        递归的实现就在于<strong>反复调用和自身函数同名的函数</strong>，并且在调用自身函数的同时，问题的范围得到一定的缩小（分解），直到分解到可以直接得出结果的边界，在边界问题得到解决后函数会通过返回，将所有已经解决的小边界问题合并，得出最终的答案。</p><hr><p>​        <strong>递归逻辑中最重要的两个概念</strong></p><p>​        <strong>①递归式</strong>（存在可以使问题不断分解的手段）</p><p>​        <strong>②递归边界</strong> （问题缩小到边界后可以得出的结论）</p><p>​        既如果需要使用递归的方法解决问题，则一定需要有可以将原问题分解为若干小问题的手段（递归式）和分解的尽头（递归边界）。</p><hr><p>​        下面以求n阶乘为例</p><p>​        由 n！ = 1 * 2 * 3····· * n  可以不难得到它的递推形式 n ！ = n * (n - 1) * (n - 2) * ······* 2 * 1。所以如果使用F(n)来表示n！，可以得到F(n) = F(n - 1)  * n 的<strong>递归式</strong>，这样问题的规模就逐渐缩小了。</p><p>​        在F(n)规模缩小为F(n - 1)后，又可以将F(n - 1) 缩小为 F(n - 2)，那么它的尽头就是F(0)的时候，且我们可以直接得出 0！= 1 ，所以F(0)就是<strong>递归边界</strong></p><p>​        在得到递归式和递归边界之后就可以用代码实现了 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">F</span> <span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//递归边界</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> F(n<span class="number">-1</span>) * n; <span class="comment">//递归式</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,F(n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>递归的详细过程</em></p><p>①假设 n 的值为3</p><p>②进入F(3)函数，判断(n == 0)不成立，返回F(2) * 3 ；F(2)还未知，程序会调用F(2)求它的值；</p><p>③进入F(2)函数，判断(n == 0)不成立，返回F(1) * 2 ；F(1)还未知，程序会调用F(1)求它的值；</p><p>④进入F(1)函数，判断(n == 0)不成立，返回F(0) * 1 ；F(0)还未知，程序会调用F(2)求它的值；</p><p>⑤进入F(0)函数，判断(n == 0)成立，返回 1；</p><p>由于F(1)等到了F(0)的值，将返回F(0) * 1 既 1 * 1 = 1;</p><p>由于F(2)等到了F(1)的值，将返回F(1) * 2 既 1 * 2 = 2；</p><p>由于F(3)等到了F(2)的值，将返回F(2)  * 3 既 2 * 3 = 6；</p><p>所以F(3) = 6；</p><p>​        <strong>Fibonacci数列</strong>也是类似的</p><p>​        递归式 F(n) = F(n - 1) + F(n - 2)</p><p>​        递归边界 F(0) = 1 和 F(1) = 1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">F</span> <span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">0</span> || n == <span class="number">1</span> ) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> F(n - <span class="number">1</span>) + F(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,F(n));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>全排列问题</strong></p></blockquote><p>​        全排列就是指由n个整数能形成的所有排列。</p><p>​        对1,2,3这三个整数来说，（1，2，3）（1，3，2）（2，1，3）（2，3，1）（3，1，2）（3，2，1）就是这三个整数按字典序从小到大的顺序的全排列。</p><p>​        若我们要排列 1~n 这n个数全排列，从递归的角度思考则把问题分解为求“以1开头的全排列”，“以2开头的全排列”，“以3开头的全排列“·····，然后对他们进行再一次分解求 “以1，2开头的全排列”，“以1，3开头的全排列”·····，以此类推，直到只剩下一个数为止。</p><p>​        所以我们就不难总结出利用递归解决全排列问题的<strong>递归式</strong>和<strong>递归边界</strong></p><p>​        <strong>下面是求1~4四个数字为例的全排列过程图</strong></p><p><img src="/2019/07/29/递归/1.jpg" alt="1"></p><blockquote><blockquote><p>递归实现1~N全排列</p></blockquote></blockquote><p>​        实现细节：</p><p>​        ①设定数组 <strong>P</strong> （index = 1~ n）存放当前的排列，在设定一个散列数组 <strong>HashTable</strong> ，若由一个数字<strong>X</strong>（1≤X≤n）已经排进数组P中，则让HashTable[X] = true</p><p>​        ②利用for循环从数组P的第一个位置开始填入X，填入后把HashTable[X]设为true，然后进行递归处理下一个位置（由于X已经被排进数组P中，HashTable[X]为true，所以在填入下一个位置时会跳过X，以免填入同样的数字），当递归完成时，再将HashTable[x] = false，以便开始在本位置填充其他数字</p><p>​        ③<strong>递归边界</strong>就是当要填入P的位置（index）等于n+1时，既P数组内所有的位置都被填满了，这个时候就进行输出就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面的课本实现的代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">11</span>;</span><br><span class="line"><span class="comment">//P为当前排列,HashTable记录整数x是否已经被排入P中</span></span><br><span class="line"><span class="keyword">int</span> n, P[maxn],hashtable[maxn] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理当前的排列中的第index位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateP</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index == n + <span class="number">1</span>)<span class="comment">// 递归边界（既P内的所有位置已经被填满）</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=n; i++) <span class="comment">//输出当前的排列</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,P[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n;x++) <span class="comment">//从第一个位置开始依次往P[index]中填入数字</span></span><br><span class="line">    <span class="keyword">if</span>(hashtable[x] == <span class="literal">false</span>) <span class="comment">//当前的x的值还未参与排列</span></span><br><span class="line">    &#123;</span><br><span class="line">        P[index] = x;<span class="comment">//将当前x的值填入排列的第index个位置</span></span><br><span class="line">        hashTable[x] = <span class="literal">true</span>;<span class="comment">//将hash值设为true表示该x值已经在排列之中</span></span><br><span class="line">        generateP(index + <span class="number">1</span>); <span class="comment">//调用同名函数处理排列的下一个位置</span></span><br><span class="line">        hashTable[x] = <span class="literal">false</span>; <span class="comment">/*已处理完P[index]位置上为x的所有子问题，既处理完了P[index]位置上以x开头的所有全排列，之后将x的hash值重设为false是为了在P[index]上填入其他数字，得到在P[index] 位置以x+1，x+2·····开头的所有全排列*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="number">4</span>;<span class="comment">//输出1~4的全排列</span></span><br><span class="line">    generateP(<span class="number">1</span>);<span class="comment">//从P[1]开始填入数字</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>n皇后问题</strong></p></blockquote><p>​        n皇后问题指的是在一个 n * n的国际象棋盘上放置 n个皇后后，使得这n个皇后两两均不在同一行，不在同一列，不在同一对角线上，求合法的方案书。</p><p>​        <strong><em>例子：五个皇后</em></strong></p><p><img src="/2019/07/29/递归/2.png" alt="2"></p><p>​        解决n皇后问题有很多方法，最暴力的方法是<strong>从n^2中选择n个位置</strong> 再从中选择满足条件的情况，那么将会有 C n^2取n （C是组合数）的枚举量，当n = 8 时，枚举量高达 54,502,232,这是无法承受的…  </p><p>​        由于每行只能放一个皇后，每一列也只能放一个皇后，如果把n列皇后所在的行号依次写出，那么会发现其实就是求就行号<strong>1~n全排列！</strong> 由于一共只有n！个排列，所以总共的枚举量在n = 8的时候只需要 40320 次，相比第一种方法会优效许多</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面是全排列求解n皇后问题的代码</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateP</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index == n+<span class="number">1</span>)<span class="comment">//递归边界</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>; <span class="comment">//flag为true时表示当前排列合法，这里先假设是合法的,再进行检验</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++) <span class="comment">//遍历任意两个皇后</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(i - j) == <span class="built_in">abs</span>(P[i] - P[j])) <span class="comment">/*由于在一条对角线上的皇后具有对称性，因此两个皇后他们的行号和列号是对称的，所以两个皇后如果在一条对角线上则会满足该语句*/</span></span><br><span class="line">                 flag = <span class="literal">false</span>;<span class="comment">//不合法</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="literal">true</span>) count++;<span class="comment">//方案合法则令count+1；</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>;x &lt;= n;x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(hashTable[x] == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            P[index] = x;</span><br><span class="line">            hashTable[x] = <span class="literal">true</span>;</span><br><span class="line">            generateP(index + <span class="number">1</span>); <span class="comment">//递归式</span></span><br><span class="line">            hashTable[x] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        虽然这一种做法比第一种做法好许多，但是仔细思考可以发现，如果我们在放置前几个皇后之后，后面的几个皇后不管怎么放置都会是不合法的话，那么其实是没有必要继续往下继续递归的(例如上图中不合法的情况，既我们放置了351的皇后，那么后两个皇后不管怎么放置都会是不合法的)直接返回上层即可，这样一来我们又可以缩减计算量，下面我们就来试试吧！</p><p>​        <strong>实现思路</strong>：在每放置一个新的皇后之后，都跟前面的皇后进行比较看是否会合法，不合法就break，合法就进行放置，并且递归进入下一个位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateP</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index == n + <span class="number">1</span>) <span class="comment">//递归边界</span></span><br><span class="line">    &#123;</span><br><span class="line">        count++; <span class="comment">// 能到达这里的都是合法排列</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n;x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(hashTable[x] == <span class="literal">false</span>)  <span class="comment">//第x行还没有皇后</span></span><br><span class="line">        &#123;</span><br><span class="line">  <span class="keyword">bool</span> flag = <span class="literal">true</span>; <span class="comment">//flag为true表示当前行的位置合法，这里先暂时假设为合法的，再进行检验</span></span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> pre = <span class="number">1</span>; pre &lt; index; pre++) <span class="comment">//遍历之前放置好的皇后</span></span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="comment">//第index列的皇后行号为x，第pre列的皇后行号为P[pre]</span></span><br><span class="line">                 <span class="keyword">if</span>(<span class="built_in">abs</span>(index - pre) == <span class="built_in">abs</span>(x - P[pre])) <span class="comment">//在同一对角线</span></span><br><span class="line">                 &#123;</span><br><span class="line">                     flag = <span class="literal">false</span>; <span class="comment">//冲突 </span></span><br><span class="line">                     <span class="keyword">break</span>; </span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="literal">true</span>) <span class="comment">// 如果在第x行的皇后是合法的 </span></span><br><span class="line">            &#123;</span><br><span class="line">                P[index] = x; <span class="comment">//把第index列皇后放在在x行</span></span><br><span class="line">                hashTable[x] = <span class="literal">true</span>; <span class="comment">//第x行已被占用</span></span><br><span class="line">                generateP(index + <span class="number">1</span>);<span class="comment">//递归处理下一列的皇后</span></span><br><span class="line">                hashTable[x] = <span class="literal">false</span>;<span class="comment">//递归完毕，返回第x行为未占用状态</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        我们把由于一些事实导致的已经不需要往任何一个子问题进行递归，而直接返回上一层的动作称为<strong>回溯法</strong>，</p><p>上面的例子就是采用回溯写法来解决n皇后问题。</p><hr><p>嘻嘻，推翻了万恶的n皇后 耶耶耶~</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 算法笔记 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法笔记-第四章-算法初步-part2-x</title>
      <link href="/2019/07/28/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5-part2-x/"/>
      <url>/2019/07/28/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5-part2-x/</url>
      
        <content type="html"><![CDATA[<p>本章涉及的内容有： </p><ul><li><p>排序 </p></li><li><p>散列 ✔</p><ul><li>散列的定义和整数散列 ✔</li><li>字符串 hash 初步 ✔</li></ul></li><li><p>递归</p></li><li><p>贪心</p></li><li><p>二分</p></li><li><p>Two Pointers</p></li><li><p>其他高效技巧与算法</p><p>**注：由于这本书的大部分例题都会以PAT呈现，所以我还会附上柳婼的解答，因为她的解答会更清爽一些！也很好理解！并且课本的代码会按自己喜好改动，并非完全一致</p></li></ul><a id="more"></a><h1 id="散列-4-2"><a href="#散列-4-2" class="headerlink" title="散列 4.2"></a>散列 4.2</h1><blockquote><p>散列的定义和整数散列</p></blockquote><p><strong>散列</strong>：将元素通过一个函数转换为整数，使得该整数可以（尽量）唯一地表示这个元素。</p><p><em>举个例子</em>：如果我们要在M = {2,3,6,5,8,7,9,11,23,55}中查找是否存在N = {2，5，4，7}这四个元素，</p><p>​        简单的办法就是在 M 中遍历所有的元素，一共遍历四次，寻找是否有元素等于2，5，4，7。这种办法的时间复杂度很明显是跟M和N集合内的数据量有关的，即O（MN) 或者说是<strong>O（n^2^）</strong></p><p>​        还有一个更好的办法就是开辟一个数组<strong>HashTable[100]</strong>（它的初始每一个值都为false）,每在<strong>M</strong>读入一个数据 <strong>X</strong> 后，便让HashTable[X] == true，表示该数据出现过。这样一来，只要再使用一个for循环遍历一次HashTable下标的每一个<strong>N</strong>内元素的值是否为true，就可以一次性全部知道M里是否有和N相等的元素。由于只使用了两个for循环，时间复杂度仅仅为O(N+M)，即<strong>O(n)</strong></p><p>​        但缺点是这样的HashTable数组里会有很多“浪费”的空间，比如从HashTabel[24<del>54]，Hash[56</del>100]的值都是0，如果M = {1，100} 那么我们将会浪费非常多的空间，<strong>但是这没有关系</strong> ，<strong>快！最重要啊朋友们！</strong></p><p>​        <strong>特别强调</strong>：<strong>HashTable数组请在main函数之外的公共区域创建</strong>，因为在main函数内开辟大小超过10^5^的HashTable数组是可能会出错的，还有创建的数组尽量<strong>&lt;=10^7^</strong> 。</p><hr><blockquote><p>散列函数</p></blockquote><p>​        在上面的例子当中，直接把N集合中的元素原值作为了HashTable的下标，在实际运用中，还可以把元素的原值通过一定的变换再作为HashTable的下标，进行这个转换工作的函数就称为<strong>散列函数</strong>。也就是说，如果元素在被转换前是key，那么转换后就是H(key)。<em>一般常用的散列函数就是按key值的原值进行输出，既H(key) = key）</em></p><blockquote><p>除留取余法 H(key) = key % mod </p></blockquote><p>​        这是个也很常用的散列函数，它是指把key值除以 一个mod值后所得到的余数作为hash值（HashTable的下标）</p><p>但是得注意表长Tsize必须满足 <strong>Tsize ≥ mod</strong> ,否则会产生下标越界。</p><blockquote><p>HashTable冲突</p></blockquote><p>​        如果不同key值通过同一个散列函数得到了相同的hash值(<em>比如7 % 5 = 2，17 mod = 2</em>)，在这种情况下，同一个hash下标是不能表示7和17的，这个时候就发生了<strong>冲突</strong></p><p>​        解决冲突的方法有<strong>线性探查法，平方探查法，链地址法</strong>，但是如果真的发生的冲突，一般是不需要我们自己实现解决冲突的方法的，只需要使用C++标准库模板的map来直接使用hash的功能。</p><hr><blockquote><p>字符串散列</p></blockquote><p>​        如果key元素并非整数，这样的话就需要设计其他的散列函数使得每一个字符都有其对应唯一的hash值。</p><p>​        下面用一个例子引出我们所要使用的散列函数</p><p>​        <strong>例：如何用一个整数唯一表达一个二维平面的点</strong> </p><p>​        我们假设一个整数点的坐标是<strong>(x，y)</strong>，其中<strong>0≤x，y≤Range</strong> ，我们令散列函数是 <strong>H(P) = x * Range + y</strong> , 这样一来，在数据范围内任意两个不同整数点P1,P2 ，H(P1) 都不会等于H(P2), 既我们可以使用这一个散列函数来<strong>唯一表示</strong>Range范围内的任一点，并且得到每一个点的hash值后，因为这时候的hash值已经是整数，所以我们可以再用其他的散列函数进一步映射来缩小得到的hash值。</p><p>​        <strong>类似的</strong>，若是是字符串的话，只要想办法把一个字符串表示为唯一的整数就可以了。</p><p>​        我们假设字符串只是从<strong>A~Z</strong>的大写字母，并且使用<strong>0~25</strong>来唯一表示A~Z的每一个字母，那如何表示一个都是大写字母的字符串呢，不难想到的办法就是利用<strong>进制转换</strong>，在上一章中我们知道任意一个P进制的数字都有办法唯一的表示为一个十进制数，所以我们可以把一个全是大写字母的字符串看成是一个<strong>26进制</strong>的“数字”，这样的话就可以利用进制转换把这个字符串唯一转换为一个10进制数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面课本里利用进制转换来变换字符串的代码</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hashfunc</span><span class="params">(<span class="keyword">char</span> S[],<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len ;i++) <span class="comment">//将26进制转换为10进制</span></span><br><span class="line">        id = id * <span class="number">26</span> + (S[i] - <span class="string">'A'</span>); </span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🍁或者可以按照P进制转换为10进制的标准格式来书写</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面也是利用进制转换来变换字符串的代码</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hashfunc</span><span class="params">(<span class="keyword">char</span> S[],<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>,product = <span class="number">1</span>,ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--)<span class="comment">//将26进制转换为10进制</span></span><br><span class="line">    &#123;</span><br><span class="line">        id = (S[i] - <span class="string">'A'</span>) * product;</span><br><span class="line">        ans += id;</span><br><span class="line">        product *= <span class="number">26</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><em>如果出现了小写字母或者是数字，那么方法也是类似的，只要把对应的进制扩大，然后再对每一个字符是大写字母，小写字母还是数字进行判断后再进行进制转换即可，可以参照下面的一个例子</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//有大写和小写的字符串</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hashfunc</span><span class="params">(<span class="keyword">char</span> S[],<span class="keyword">int</span> len)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lem ;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(S[i] &gt;= <span class="string">'A'</span> &amp;&amp; S[i] &lt;= <span class="string">'Z'</span>)</span><br><span class="line">            id = id * <span class="number">52</span> + (S[i] - <span class="string">'A'</span>);</span><br><span class="line">        <span class="keyword">if</span>(S[i] &gt;= <span class="string">'a'</span> &amp;&amp; S[i] &lt;= <span class="string">'z'</span>)</span><br><span class="line">            id = id * <span class="number">52</span> + (S[i] - <span class="string">'a'</span>) + <span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>下面看最后一个问题，给出N个字符串(每个字符串恰好由三个大写字母组成)，再给出M个查询字符串（也由三个大写字母组成），问每个查询字符串在N个字符串中出现的次数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span>;<span class="comment">//给出的字符串不超过100个</span></span><br><span class="line"><span class="keyword">char</span> S[maxn][<span class="number">5</span>],temp[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> hashTable[<span class="number">26</span>*<span class="number">26</span>*<span class="number">26</span>+<span class="number">10</span>]; <span class="comment">//26进制转化为最大10进制的整数是26^位数-1，即（26^3 - 1）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashFunc</span><span class="params">(<span class="keyword">char</span> S[],<span class="keyword">int</span> len)</span> <span class="comment">//散列函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len;i++)</span><br><span class="line">        id = id * <span class="number">26</span> + (S[i] - <span class="string">'A'</span>);</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,S[i]);</span><br><span class="line">    <span class="keyword">int</span> id = hashFunc(S[i],<span class="number">3</span>); <span class="comment">//计算N个字符串的Hash值</span></span><br><span class="line">        HashTable[id]++;<span class="comment">//该字符串出现的次数+1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,temp);</span><br><span class="line">        <span class="keyword">int</span> id = hashFunc(temp,<span class="number">3</span>);<span class="comment">//计算查询字符串对应的Hash值</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,hashTable[id]);<span class="comment">//输出查询字符串出现的字数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 算法笔记 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法笔记-第四章-算法初步-part1-x</title>
      <link href="/2019/07/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5-part1-x/"/>
      <url>/2019/07/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5-part1-x/</url>
      
        <content type="html"><![CDATA[<p>本章涉及的内容有： </p><ul><li><p>排序 ✔</p><ul><li><p>选择排序 ✔</p></li><li><p>插入排序 ✔</p></li><li><p>排序题与sort函数的应用 ✔</p></li></ul></li><li><p>散列</p></li><li><p>递归</p></li><li><p>贪心</p></li><li><p>二分</p></li><li><p>Two Pointers</p></li><li><p>其他高效技巧与算法</p><p><strong>注：由于这本书的大部分例题都会以PAT呈现，所以我还会附上柳婼的解答，因为她的解答会更清爽一些！也很好理解！并且课本的代码会按自己喜好改动，并非完全一致</strong></p></li></ul>  <a id="more"></a><h1 id="排序4-1"><a href="#排序4-1" class="headerlink" title="排序4.1"></a>排序4.1</h1><blockquote><p><strong>选择排序4.1.1</strong></p></blockquote><p>每次从<strong>[i,n</strong>]中选出<strong>最小</strong>的值，与<strong>A[i]交换</strong>（先看算法逻辑【在下面】再看图）</p><p><img src="/2019/07/25/算法笔记-第四章-算法初步-part1-x/1.jpg" alt="耶耶耶~"></p><p>​    </p><p>​    <strong>算法逻辑</strong>：总共需要进行<strong>n趟</strong>（1≤i≤n）操作，每趟操作选出未排序部分<strong>[i,n]</strong>中<strong>最小</strong>的元素，令其与<strong>A[i]</strong>进行<strong>交换</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现代码如下 </span></span><br><span class="line">注意：下标从<span class="number">1</span>~n</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; j++)<span class="comment">//进行n趟操作</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k = i; <span class="comment">//每趟操作都先假设未排序的第一个元素为最小的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= n; j++) <span class="comment">//选出[i,n]中最小的元素，其下标为k</span></span><br><span class="line">            <span class="keyword">if</span>(A[j] &lt;A[k]) k = j;</span><br><span class="line">        <span class="comment">//👆找了一轮内最小的元素</span></span><br><span class="line">        <span class="comment">//👇交换</span></span><br><span class="line">        <span class="keyword">int</span> temp = A[i];</span><br><span class="line">        A[i] = A[k];</span><br><span class="line">        A[k] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p><strong>插入排序4.1.2</strong></p></blockquote><p>序列B的下标依旧是从<strong>1~n</strong> ，每次取出未排序部分的第一个元素，比较后插入有序序列（先看算法逻辑再看图）</p><p><img src="/2019/07/25/算法笔记-第四章-算法初步-part1-x/2.jpg" alt="耶耶耶~"></p><p><strong>算法逻辑</strong>：总共需要进行<strong>n-1</strong>趟操作，因为一开始我们可以把待排序序列的第一个元素当作有序序列的第一个元素，这样一来，循环就可以从<strong>i = 2</strong>开始遍历到<strong>i = n</strong> ；每遍历一个元素，便先将元素暂时存储到<strong>temp</strong>中，再而从该元素的当前位置<strong>B[ j ]</strong>(该元素位置前的所有元素是已经排序好的有序序列）开始往前（<strong>j–</strong>）逐一比较，如果被比较的元素<strong>较大</strong>，则被比较的元素<strong>往后挪一位</strong>，当遇到比temp小的元素或者temp已经和所有的有序序列元素比较完毕后，跳出循环，此时的有序序列中所有比temp大的元素都被向后挪了一位，将<strong>temp插入</strong>当前<strong>B[ j ]</strong>的位置就可以完成此次temp的排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//课本代码</span></span><br><span class="line"><span class="keyword">int</span> B[maxn],n;<span class="comment">//n为元素个数，数组下标为1~n</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = B[i], j = i;<span class="comment">//temp临时存放B[i]， j从i开始往前枚举比较</span></span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">1</span> &amp;&amp; B[j - <span class="number">1</span>] &gt; temp)<span class="comment">//只要不比完或前一个元素比temp大 循环就继续</span></span><br><span class="line">        &#123;</span><br><span class="line">            B[j] = B[j - <span class="number">1</span>]; <span class="comment">//比temp大的元素往后挪一位</span></span><br><span class="line">            j--；</span><br><span class="line">        &#125;</span><br><span class="line">        B[j] = temp; <span class="comment">//插入temp</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p><strong>排序题与sort函数的应用</strong></p></blockquote><p>​        在实际的PTA考试里是不需要我们手打排序算法的 = =，只需要使用C++的sort函数对序列进行排序，而且使用它大概率<strong>比你手写</strong>的排序算法<strong>快</strong>hahah。（sort的简单使用方法看看下面的例子就差不多会了！）</p><p><strong>例1：初见sort函数</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>] = &#123;<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>&#125;;</span><br><span class="line">sort(a,a+<span class="number">3</span>);<span class="comment">//a[0] ~ a[2] 从小到大排序</span></span><br></pre></td></tr></table></figure><p><strong>sort(首元素地址，尾元素的下一个地址，cmp函数)</strong>  其中cmp函数若不填则是从小到大排序</p><p><strong>例2：字符串的字典序</strong></p><p>①分数高的排前面</p><p>②分数相同名字字典序小的排前面</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span> <span class="params">(Student a, Student b)</span></span></span><br><span class="line"><span class="function"><span class="comment">//sort函数中最重要的就是cmp函数的书写</span></span></span><br><span class="line"><span class="function"><span class="comment">//可以多体验几道题</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.score != b.score) <span class="keyword">return</span> a.score &gt; b.score; <span class="comment">//分数不同则高的在前</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">strcmp</span> (a.name,b.name) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>strcmp() ?!</strong></p><ul><li>利用char数组存储的字符串可以利用strcmp()函数进行比较字典序大小</li><li>若strcmp(str1,str2)<ul><li><strong>str1</strong>字典序<strong>小于str2</strong>时，返回一个<strong>负数</strong></li><li><strong>str1</strong>字典序<strong>大于str2</strong>时，返回一个<strong>正数</strong></li><li><strong>str1</strong>字典序<strong>等于str2</strong>时，返回<strong>零</strong></li></ul></li></ul><p>所以例2中strcmp(a.name,b.name) &lt;0 代表在分数相等的情况下，当a的字典序小于b的时将return true，即按字典序从小到大排列。</p><p><strong>例3：分数相同，排名相同</strong></p><p>①（记录排名再输出）</p><p>实现逻辑：先令数组的<strong>第一个个体</strong>（index = 0）<strong>排名为1</strong>，然后从第二个个体开始遍历所有的个体，如果当前个体和上一个个体<strong>分数相同</strong>，则该个体的排名也等于上一个个体的排名，如果<strong>分数不相同</strong>，则当前个体的排名等于当前的下标<strong>index + 1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stu[<span class="number">0</span>].r = <span class="number">1</span>;<span class="comment">//第一个元素排名为1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n ;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(stu[i].score == stu[i<span class="number">-1</span>].score) stu[i].r = stu[i - <span class="number">1</span>].r;</span><br><span class="line">    <span class="keyword">else</span> stu[i].r = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②(直接输出排名)</p><p>实现逻辑：和上面差不多啦<del>~</del></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( i &gt; <span class="number">0</span> &amp;&amp; stu[i].score != stu[i - <span class="number">1</span>].score) r = i + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>做个题：</p><blockquote><h2 id="【PAT-A1025】PAT-ranking"><a href="#【PAT-A1025】PAT-ranking" class="headerlink" title="【PAT A1025】PAT ranking"></a>【PAT A1025】PAT ranking</h2></blockquote><p>Programming Ability Test (PAT) is organized by the College of Computer Science and Technology of Zhejiang University. Each test is supposed to run simultaneously in several places, and the ranklists will be merged immediately after the test. Now it is your job to write a program to correctly merge all the ranklists and generate the final rank.</p><p><strong>Input Specification:</strong></p><p>Each input file contains one test case. For each case, the first line contains a positive number <em>N</em> (≤100), the number of test locations. Then <em>N</em>ranklists follow, each starts with a line containing a positive integer <em>K</em> (≤300), the number of testees, and then <em>K</em> lines containing the registration number (a 13-digit number) and the total score of each testee. All the numbers in a line are separated by a space.</p><p> <strong>Output Specification:</strong></p><p>For each test case, first print in one line the total number of testees. Then print the final ranklist in the following format:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">registration_number</span> final_rank location_number local_rank</span><br></pre></td></tr></table></figure><p>The locations are numbered from 1 to <em>N</em>. The output must be sorted in nondecreasing order of the final ranks. The testees with the same score must have the same rank, and the output must be sorted in nondecreasing order of their registration numbers.</p><p><strong>Sample Input:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">5</span><br><span class="line">1234567890001 95</span><br><span class="line">1234567890005 100</span><br><span class="line">1234567890003 95</span><br><span class="line">1234567890002 77</span><br><span class="line">1234567890004 85</span><br><span class="line">4</span><br><span class="line">1234567890013 65</span><br><span class="line">1234567890011 25</span><br><span class="line">1234567890014 100</span><br><span class="line">1234567890012 85</span><br></pre></td></tr></table></figure><p><strong>Sample Output:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">9</span><br><span class="line">1234567890005 1 1 1</span><br><span class="line">1234567890014 1 2 1</span><br><span class="line">1234567890001 3 1 2</span><br><span class="line">1234567890003 3 1 2</span><br><span class="line">1234567890004 5 1 4</span><br><span class="line">1234567890012 5 2 2</span><br><span class="line">1234567890002 7 1 5</span><br><span class="line">1234567890013 8 2 3</span><br><span class="line">1234567890011 9 2 4</span><br></pre></td></tr></table></figure><p><strong>题目大意：</strong> 有<strong>n</strong>个PAT考场，每个考场<strong>k</strong>人，给你每个人准考证号 ，让你按考生的分数从高到低排序，并按顺序输出所有考生的准考证号，排名，考场号，考场排名，按每个人的分数升序输出，若分数相同则排名相同，排名相同时按准考号从小到大排列。</p><p><strong>分析：</strong>①按各个考场读入各考生的信息，使用student结构体储存考生的准考证号，排名，考场号，考场内的排名 ,</p><p>读入完毕后对该考场的考生进行排序。</p><p>②对所有考生进行排序 </p><p>③按顺序计算总排名，并输出。</p><p><strong>实现细节：</strong> 对同一考场的考生单独排序的方法：先定义一个int变量<strong>num = 0</strong>，每读入一个考生就让<strong>num++</strong> ，</p><p>若一个考场有k个考生，则这个考场所有考生的下标的就是 <strong>[num - k , num)</strong> ,然后再使用sort函数就可以了</p><blockquote><p>下面是关于为什么是 <strong>[num - k , num)</strong> 的解释。</p><p><strong>再次注意num是考生读入完毕后再加一</strong></p></blockquote><p><img src="/2019/07/25/算法笔记-第四章-算法初步-part1-x/3.jpg" alt="耶耶耶~"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 课本代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> id[<span class="number">15</span>]; <span class="comment">//准考证号</span></span><br><span class="line">    <span class="keyword">int</span>  score; <span class="comment">//分数</span></span><br><span class="line">    <span class="keyword">int</span>  location_number; <span class="comment">//考场号</span></span><br><span class="line">    <span class="keyword">int</span>  local_rank; <span class="comment">//考场内排名</span></span><br><span class="line">&#125;stu[<span class="number">30010</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span> <span class="params">(student a, student b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.score != b.score) <span class="keyword">return</span> a.score &gt; b.score ; <span class="comment">//按分数从高到低排列</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">strcmp</span>(a.id,b.id) &lt; <span class="number">0</span>;<span class="comment">//分数相同，id小的排前面</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// n 考场数 k为一个考场的人数 num为总考生数</span></span><br><span class="line"><span class="keyword">int</span> n, k, num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k); </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k ;j++) <span class="comment">//读取该考场的考生</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s %d"</span>,&amp;stu[num].id,&amp;stu[num].score);</span><br><span class="line">            stu[num].location_number = i;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(stu + (num - k), stu + num, cmp); <span class="comment">//对该考场的考生进行排序</span></span><br><span class="line">        stu[num - k].local_rank = <span class="number">1</span>;<span class="comment">//该考场的第一个考试的考场排名为1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = (num - k) + <span class="number">1</span>; j &lt; num; j++)<span class="comment">//从该考场的第二个考生开始遍历</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//分数相同，local_rank也相同</span></span><br><span class="line">            <span class="keyword">if</span>(stu[j].score == stu[j<span class="number">-1</span>].score) stu[j].local_rank = stu[j<span class="number">-1</span>].local_rank;</span><br><span class="line">            <span class="keyword">else</span> stu[j].local_rank =  j - (num - k) + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//j是这个考生的下标，num - k是这个考场第一个考生的下标，为什么加一可以参考例三</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//👆student小卡片读入完毕</span></span><br><span class="line">    <span class="comment">//👇输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,num);</span><br><span class="line">    sort(stu, stu + num,cmp); <span class="comment">//把全部考生按分数全部重新排序</span></span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">1</span>; <span class="comment">//总排名的第一位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; stu[i].score != stu[i - <span class="number">1</span>].score) r = i + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s "</span>,stu[i].id);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, r, stu[i].location_number,stu[i].local_rank);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>💒柳婼的解答思路基本和课本相同，最大的不同是她在对每一个考场的考生进行操作的时候，使用了vector单独对每一个考场的考生进行操作，操作完毕之后再把他们放入总数组fin，这样就可以避免课本的解答中一开始就让所有的考生都在同一个数组中进行处理，进而出现(num - k)，j - (num - k) + 1这种令人费解的运算。（但还是推荐先看课本的解答后再看柳婼的解答，他们最大的区别就是是否使用了C++的标准模板库STL）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//柳婼</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">int</span> score,finrank,loca,locarank;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(student a, student b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.score != b.score ? a.score &gt; b.score : a.no &lt; b.no;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;student&gt; fin;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">        <span class="built_in">vector</span>&lt;student&gt; v(m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m ;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld %d"</span>,&amp;v[j].no,&amp;v[j].score);</span><br><span class="line">            v[j].loca = i;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(v.begin(),v.end(),cmp1);</span><br><span class="line">        v[<span class="number">0</span>].locarank = <span class="number">1</span>;</span><br><span class="line">        fin.push_back(v[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; m; j++)&#123;</span><br><span class="line">            v[j].locarank = (v[j].score == v[j - <span class="number">1</span>].score) ? (v[j<span class="number">-1</span>].locarank) : (j + <span class="number">1</span>);</span><br><span class="line">            fin.push_back(v[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(fin.begin(),fin.end(),cmp1);</span><br><span class="line">    fin[<span class="number">0</span>].finrank = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; fin.size();j++)</span><br><span class="line">        fin[j].finrank = (fin[j].score == fin[j - <span class="number">1</span>].score) ? (fin[j - <span class="number">1</span>].finrank) :(j + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,fin.size());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fin.size();i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%013lld %d %d %d\n"</span>,fin[i].no, fin[i].finrank, fin[i].loca, fin[i].locarank);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 算法笔记 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法笔记第三章 入门模拟 2/2</title>
      <link href="/2019/07/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%85%A5%E9%97%A8%E6%A8%A1%E6%8B%9F-part2-2/"/>
      <url>/2019/07/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%85%A5%E9%97%A8%E6%A8%A1%E6%8B%9F-part2-2/</url>
      
        <content type="html"><![CDATA[<p>本章涉及的内容有： </p><ul><li><p>简单模拟 </p></li><li><p>查找元素 </p></li><li><p>图形输出 </p></li><li><p>日期处理 </p></li><li><p>进制转换 （重要）✔</p></li><li><p>字符串处理 （重要）✔</p><p><strong>注：由于这本书的大部分例题都会以PAT呈现，所以我还会附上柳婼的解答，因为她的解答会更清爽一些！也很好理解！并且课本的代码会按自己喜好改动，并非完全一致</strong></p><a id="more"></a></li></ul><hr><h1 id="进制转换-3-5-（重要）"><a href="#进制转换-3-5-（重要）" class="headerlink" title="进制转换 3.5 （重要）"></a>进制转换 3.5 （重要）</h1><p>✨<strong>思路</strong> ：由P进制数转化为Q进制数只需要2步</p><p>①将P进制数转化为十进制数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">假设一个P进制数为 a1a2·····an <span class="comment">//n为下标</span></span><br><span class="line">则其对应的十进制数为 y = an * P^<span class="number">0</span> + a(n<span class="number">-1</span>) * P^<span class="number">1</span> + ····· + a1 * P^(n<span class="number">-1</span>) </span><br><span class="line">     举个例子 (<span class="number">8</span> 进制数的) <span class="number">321</span> == (十进制的) <span class="number">3</span>*<span class="number">8</span>^<span class="number">2</span> + <span class="number">2</span>*<span class="number">8</span>^<span class="number">1</span> + <span class="number">1</span>*<span class="number">8</span>^<span class="number">0</span> = <span class="number">209</span> </span><br><span class="line"><span class="comment">//下面是代码</span></span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">0</span>,product = <span class="number">1</span>; <span class="comment">//初始化 这里的product其实是P的零次</span></span><br><span class="line"><span class="keyword">while</span>(x != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        y = y + ( x % <span class="number">10</span> ) * product; <span class="comment">//x%10获得x的最后一位数，再把它乘上对应的Product</span></span><br><span class="line">        x = x / <span class="number">10</span>; <span class="comment">//获取x的最后一位之后将其删掉</span></span><br><span class="line">        product = product * P; <span class="comment">// 幂加一 也就是再乘一个P</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>②将其十进制数转化为Q进制数</p><p>采用<strong>除基取余法</strong>，以课本为例，体会一下就可以知道了。（基就是进制<strong>Q</strong>）</p><blockquote><p>将11（这是一个十进制数）转为为2进制数</p><p>11 除以 2，得<strong>商</strong>为 <strong>5</strong>，<strong>余数</strong>为 <strong>1</strong>；</p><p>5 除以 2，得<strong>商</strong>为 <strong>2</strong>，<strong>余数</strong>为 <strong>1</strong>；</p><p>2 除以 2 ，得<strong>商</strong>为 <strong>1</strong>，<strong>余数</strong>为 0；</p><p>1 除以 2 ，得<strong>商</strong>为<strong>0</strong>，<strong>余数</strong>为1；</p><p><strong>商为0时</strong>，动作结束，<strong>逆向输出</strong>获得的所有余数</p><p>即转化成的二进制数为<strong>1011</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面是代码</span></span><br><span class="line"><span class="keyword">int</span> z[<span class="number">40</span>],num = <span class="number">0</span>; <span class="comment">//用数组z来获得每一步除法得到的余数，并用num记录下标，当循环结束时，num是z的元素个数</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    z[num++] = y % Q; <span class="comment">//获得每一步的余数 即除基取余</span></span><br><span class="line">    y = y / Q;</span><br><span class="line">&#125;<span class="keyword">while</span>(y!=<span class="number">0</span>);</span><br><span class="line">注意这里一定要用<span class="keyword">do</span>循环，为了避免输入为<span class="number">0</span>时用<span class="keyword">while</span>是一次循环都不能进去的</span><br><span class="line">当<span class="keyword">do</span>时，即使是<span class="number">0</span>也可以得到输出为<span class="number">0</span>的结果</span><br></pre></td></tr></table></figure><hr><blockquote><p><strong>【PTA B1022】 D进制的A+B</strong></p></blockquote><p>输入两个非负 10 进制整数 <em>A</em> 和 <em>B</em> (≤230−1)，输出 <em>A</em>+<em>B</em> 的 <em>D</em> (1&lt;<em>D</em>≤10)进制数。</p><p> <strong>输入格式</strong>：</p><p>输入在一行中依次给出 3 个整数 <em>A</em>、<em>B</em> 和 <em>D</em>。</p><p><strong>输出格式</strong>：</p><p>输出 <em>A</em>+<em>B</em> 的 <em>D</em> 进制数。</p><p><strong>输入样例</strong>：</p><p>123 456 8</p><p><strong>输出样例</strong>：</p><p>1103</p><blockquote><p><strong>😱分析</strong>：emmmm就把他们加起来再进制转换嘛…</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//课本代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, d;<span class="comment">//a和b是俩操作数 d是进制</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;d);</span><br><span class="line">    <span class="keyword">int</span> sum = a + b;</span><br><span class="line">    <span class="keyword">int</span> ans[<span class="number">31</span>], num = <span class="number">0</span>;<span class="comment">//ans存放每一位余数，用num记录下标，当循环结束时，num是z的元素个数</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        ans[sum++] = sum % d;</span><br><span class="line">        sum /= d</span><br><span class="line">    &#125;<span class="keyword">while</span>(sum != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = num - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans[i]); <span class="comment">//倒序输出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🥗</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//柳婼</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, d;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; d;</span><br><span class="line">    <span class="keyword">int</span> t = a + b;</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> s[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(t != <span class="number">0</span>)&#123;</span><br><span class="line">        s[i++] = t % d;</span><br><span class="line">        t /= d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>;j--)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s[j];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="字符串处理-3-6（重要）"><a href="#字符串处理-3-6（重要）" class="headerlink" title="字符串处理 3.6（重要）"></a>字符串处理 3.6（重要）</h1><p>✨<strong>思路</strong>：分析清楚题目的输入和输出<strong>格式</strong>，还要考虑到<strong>细节和边界</strong>。</p><p>🎈<strong>注意</strong>：①<strong>scanf</strong>除了使用<strong>%c</strong>读入以外，使用其他格式符<strong>读入</strong>（如%s）的时候都是以<strong>空白符</strong>（空格，换行）作为<strong>读入结束</strong>判断标志</p><p>②使用<strong>char数组</strong>表示字符串的时候，数组<strong>末尾</strong>一定要有<strong>结束符 \0</strong> ，否则<strong>printf</strong>和<strong>puts</strong>输出字符串的时候将<strong>无法识别正确</strong>，<strong>我们一般使用scanf的%s读入或者使用gets函数读入后，会自动在char数组末尾添加结束符\0</strong> ，并不需要手动添加结束符\0（但是在一定要使用其他函数（如<strong>getchar</strong>）读入字符串的时候，<strong>要手动在char数组末尾添加结束符\0</strong>）</p><hr><blockquote><p>​                                            <strong>【codeup 5901】回文串</strong></p></blockquote><p>题目描述</p><p>读入一串字符，判断是否是回文串。“回文串”是一个正读和反读都一样的字符串，比如“level”或者“noon”等等就是回文串。</p><p> <strong>输入</strong></p><p>一行字符串，长度不超过255。</p><p> <strong>输出</strong></p><p>如果是回文串，输出“YES”，否则输出“NO”。</p><p> <strong>样例输入</strong></p><p>12321</p><p><strong>样例输出</strong></p><p>YES</p><blockquote><p><strong>👜分析</strong>：先看个图</p></blockquote><blockquote><p><img src="/2019/07/25/算法笔记-第三章-入门模拟-part2-2/1.jpg" alt="耶耶耶~"></p><p>从图中不难看出来元素个数是奇数或偶数都可以用同样的办法处理，即比较<strong>char数组</strong>中的<strong>下标</strong>第<strong>i</strong>个和第<strong>len-i-1</strong>是否相同就可以判断是否为回文串。</p><p>​        在实际<strong>遍历</strong>操作时只需用遍历字符串中间位置的<strong>前一半</strong>就可以了，即只需要取到 <strong>i == len / 2</strong> 的前一半的<strong>下标</strong>，进行比较就可以。 </p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//课本代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">256</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">char</span> str[])</span> <span class="comment">//判断是否为回文串</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str); <span class="comment">//字符串长度</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">2</span>; i++)<span class="comment">//遍历字符串i == len / 2的前一半的下标</span></span><br><span class="line">        <span class="keyword">if</span>(str[i] != str[len - i - <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//当对称部分都相同时 或者 输入为一个字符的时候 返回true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123; <span class="comment">//这里改为黑框直接运行的代码</span></span><br><span class="line">    <span class="keyword">char</span> str[maxn];</span><br><span class="line">    gets(str); <span class="comment">//输入字符串</span></span><br><span class="line">    <span class="comment">//👆输入</span></span><br><span class="line">    <span class="comment">//👇输出</span></span><br><span class="line">    <span class="keyword">if</span>(judge(str)) <span class="built_in">printf</span>(<span class="string">"YES\n"</span>); <span class="comment">//str是回文串</span></span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO\n"</span>); <span class="comment">//不是回文串</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p><strong>【PAT B1009】 说反话</strong></p></blockquote><p>给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。</p><p> <strong>输入格式</strong>：</p><p>测试输入包含一个测试用例，在一行内给出总长度不超过 80 的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用 1 个空格分开，输入保证句子末尾没有多余的空格。</p><p> <strong>输出格式</strong>：</p><p>每个测试用例的输出占一行，输出倒序后的句子。</p><p> <strong>输入样例</strong>：</p><p>Hello World Here I Come</p><p> <strong>输出样例</strong>：</p><p>Come I Here World Hello</p><blockquote><p><strong>🚎分析</strong>： 用<strong>char一维数组</strong>储存字符串，用<strong>gets</strong>读入一行的全部字符（gets会自动在char数组末尾添加\0），</p><p>再建立<strong>char二维数组</strong>储存每一个单词。之后再逆向输出即可</p><p>实现细节：遍历所有char一位数组里的所有字符，<strong>逐个读入</strong>二维数组中，若<strong>遇到空格</strong> ，就<strong>加上</strong>结束符<strong>\0</strong>，</p><p><strong>注意</strong>：遍历一位数组的范围应该从<strong>下标</strong> <strong>0</strong>开始到<strong>len</strong>（这是为了读入char一维数组里的最后一个结束符）而<strong>不是len-1</strong>，原题代码只遍历到len-1，所以在输入一些样例的时候会有<strong>乱码</strong>出现。（你可以输入1 2 3试试）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="comment">//PTA提交的时候需要把上面的头文件删除 编译器选择C 再把头文件改为#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">90</span>]; <span class="comment">//一维数组存放一整行字符串</span></span><br><span class="line">    gets(str);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str), r = <span class="number">0</span>, h = <span class="number">0</span>; <span class="comment">//r为行 h为列</span></span><br><span class="line">    <span class="keyword">char</span> ans[<span class="number">90</span>][<span class="number">90</span>]; <span class="comment">//二维数组 存放每一个单词</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len ; i++) <span class="comment">//这是里从0到len哦！</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i] != <span class="string">' '</span>) ans[r][h++] = str[i]; <span class="comment">//</span></span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//如果是空格，说明一个单词结束，单词末尾添加结束符，再让r+1读取下一个字母并h重置为0</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans[r][h] = <span class="string">'\0'</span>;</span><br><span class="line">            r++;</span><br><span class="line">            h = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = r ;i &gt;= <span class="number">0</span>; i--) </span><br><span class="line">    <span class="comment">//最后一个单词的结束符输入是由if语句完成的而不是else 所以这里r == 总单词数 -1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>,ans[i]);</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🚄</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//柳婼</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; s) v.push(s);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v.top();</span><br><span class="line">    v.pop();</span><br><span class="line">    <span class="keyword">while</span>(!v.empty())&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">" "</span> &lt;&lt; v.top();</span><br><span class="line">        v.pop();</span><br><span class="line">    &#125;<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>👾C++真方便 落泪</p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 算法笔记 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法笔记第三章 入门模拟 1/2</title>
      <link href="/2019/07/24/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%85%A5%E9%97%A8%E6%A8%A1%E6%8B%9F-part1-2/"/>
      <url>/2019/07/24/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%85%A5%E9%97%A8%E6%A8%A1%E6%8B%9F-part1-2/</url>
      
        <content type="html"><![CDATA[<p>本章涉及的内容有： </p><ul><li><p>简单模拟 ✔</p></li><li><p>查找元素 ✔</p></li><li><p>图形输出 ✔</p></li><li><p>日期处理 ✔</p></li><li><p>进制转换 （重要）</p></li><li><p>字符串处理 （重要）</p><p><strong>注：由于这本书的大部分例题都会以PAT呈现，所以我还会附上柳婼的解答，因为她的解答会更清爽一些！也很好理解！并且课本的代码会按自己喜好改动，并非完全一致</strong></p><a id="more"></a></li></ul><h1 id="简单模拟-3-1"><a href="#简单模拟-3-1" class="headerlink" title="简单模拟 3.1"></a>简单模拟 3.1</h1><p><strong>思路</strong> ：模拟题干就可👍</p><hr><h3 id><a href="#" class="headerlink" title=" "></a> </h3><blockquote><p>​                                   【 PAT（basic）1001 】害死人不偿命的（3n+1）猜想</p></blockquote><p>卡拉兹(Callatz)猜想：</p><p>对任何一个正整数 <em>n</em>，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把 (3<em>n</em>+1) 砍掉一半。这样一直反复砍下去，最后一定在某一步得到 <em>n</em>=1。卡拉兹在 1950 年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证 (3<em>n</em>+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……</p><p>我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过 1000 的正整数 <em>n</em>，简单地数一下，需要多少步（砍几下）才能得到 <em>n</em>=1？</p><p><strong>输入格式：</strong></p><p>每个测试输入包含 1 个测试用例，即给出正整数 <em>n</em> 的值。</p><p><strong>输出格式：</strong></p><p>输出从 <em>n</em> 计算到 1 需要的步数。</p><p><strong>输入样例</strong></p><p>3</p><p> <strong>输出样例</strong></p><p>5</p><hr><p><strong>分析</strong>：当<strong>n</strong>不为<strong>1</strong>时，<strong>n</strong>为奇数就将<strong>n</strong>乘以<strong>3n+1</strong>，是偶数就将<strong>n</strong>除以2；</p><p>每进行一次计算就令<strong>step</strong>加<strong>1</strong>；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//课本代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, step = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n); <span class="comment">//输入题目所给的n</span></span><br><span class="line">    <span class="keyword">while</span>(n != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>) n = n / <span class="number">2</span>; <span class="comment">//n为偶数时</span></span><br><span class="line">        <span class="keyword">else</span> n = (<span class="number">3</span> * n + <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">//n为奇数时</span></span><br><span class="line">        step++; <span class="comment">//计数器加一</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,step);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嘿嘿嘿留个小空行🤗</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//柳婼</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n != <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">2</span> != <span class="number">0</span>) n = n * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">        n = n / <span class="number">2</span>;</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>​                                              【 PAT（basic）1032 】挖掘机技术哪家强</p></blockquote><p>为了用事实说明挖掘机技术到底哪家强，PAT 组织了一场挖掘机技能大赛。现请你根据比赛结果统计出技术最强的那个学校。</p><p><strong>输入格式：</strong></p><p>输入在第 1 行给出不超过 105 的正整数 <em>N</em>，即参赛人数。随后 <em>N</em> 行，每行给出一位参赛者的信息和成绩，包括其所代表的学校的编号（从 1 开始连续编号）、及其比赛成绩（百分制），中间以空格分隔。</p><p> <strong>输出格式：</strong></p><p>在一行中给出总得分最高的学校的编号、及其总分，中间以空格分隔。题目保证答案唯一，没有并列。</p><p> <strong>输入样例</strong></p><p>6<br>3 65<br>2 80<br>1 100<br>2 70<br>3 40<br>3 0</p><p> <strong>输出样例</strong></p><p>2 150</p><hr><p><strong>分析</strong>：利用一维数组<strong>school[100010]</strong>记录下每个学校的总分，题干所给的编号可以直接当作<strong>school</strong>数组的下标，记录完毕后利用<strong>for</strong>循环从第一个开始寻找<strong>school</strong>中<strong>最大的元素</strong>以及所<strong>对应的下标</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//课本代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> school [maxn] = &#123;<span class="number">0</span>&#125;; <span class="comment">//将数组内的元素全部初始化为0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, schID, score;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n); <span class="comment">//n为学校总数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;schID,&amp;score);<span class="comment">//读入学校ID 对应分数</span></span><br><span class="line">        school[schID] += score; <span class="comment">//学校schID的总分加score</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//👆读入完毕</span></span><br><span class="line">    <span class="comment">//👇进行查找</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>, MAX = <span class="number">-1</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(school[i] &gt; MAX)<span class="comment">//若有元素school[i]大于之前的MAX</span></span><br><span class="line">        &#123;</span><br><span class="line">            MAX = school[i];<span class="comment">//将MAX赋予新的值</span></span><br><span class="line">            k = i;<span class="comment">//记录最大元素的下标</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, k, MAX);<span class="comment">//按格式输出最高总分的学校序号和对应分数 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🎑</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//柳婼</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(N + <span class="number">1</span>); <span class="comment">//创建元素个数为N+1，元素类型为int的动态数组a；</span></span><br><span class="line">    <span class="keyword">int</span> num, score;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num &gt;&gt; score;</span><br><span class="line">        a[num] += score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//👆读入完毕</span></span><br><span class="line">    <span class="comment">//👇进行查找</span></span><br><span class="line">    <span class="keyword">int</span> max = a[<span class="number">1</span>], t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i&lt;= N; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(max &lt; a[i])&#123;<span class="comment">//若有元素school[i]大于之前的MAX</span></span><br><span class="line">            max = a[i];<span class="comment">//将MAX赋予新的值</span></span><br><span class="line">            t = i;<span class="comment">//记录最大元素的下标</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="string">" "</span> &lt;&lt; max;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>提示：用<strong>cout</strong>和<strong>cin</strong>进行大量数据读入和输出的时候不是明智的选择，如果超时应该选择用scanf和printf进行读入和输出，还有如果使用C++里的<strong>string</strong>类的话只能用cin和cout进行处理。</em></p><hr><h1 id="查找元素-3-2"><a href="#查找元素-3-2" class="headerlink" title="查找元素 3.2"></a>查找元素 3.2</h1><p><strong>思路</strong> ：此处为简单的查找，直接遍历每一个数据就可以了，之后章节会有更快的查找方式，如二分查找😄</p><p><em>注：由于这本书的大部分例题都会以PAT呈现，所以我还会附上柳婼的解答，因为她的解答会更清爽一些！也很好理解！</em></p><h2 id="【codeup-1935-】找x"><a href="#【codeup-1935-】找x" class="headerlink" title="【codeup 1935 】找x"></a>【codeup 1935 】找x</h2><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个数n，然后输入n个数值各不相同，再输入一个值x，输出这个值在这个数组中的下标（从0开始，若不在数组中则输出-1）。</p><p> <strong>输入格式：</strong></p><p>测试数据有多组，输入n(1&lt;=n&lt;=200)，接着输入n个数，然后输入x。</p><p> <strong>输出格式：</strong></p><p>对于每组输入,请输出结果。</p><p> <strong>输入样例</strong></p><p>4<br>1 2 3 4<br>3</p><p> <strong>输出样例</strong></p><p>2</p><hr><p><strong>分析</strong>：emmm就直接遍历找嘛…最后如果没有找到的话即 <strong>k == n</strong> 时输出-1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">210</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, x;</span><br><span class="line">    <span class="keyword">while</span>(<span class="string">"%d"</span>, &amp;n) != EOF)<span class="comment">//输入未到文件结尾End of file(因为codeup是多点测试需要这样进行输入)</span></span><br><span class="line">         <span class="comment">//如果是PAT(单点测试)直接scanf读取就可以了 </span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]); <span class="comment">//读入n个数</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x); <span class="comment">//读入需要查找的x</span></span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; n; k++) <span class="comment">//遍历</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[k] == x) <span class="comment">//如果找到了值与x相等的元素</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d"</span>,&amp;k); <span class="comment">//输出它的下标</span></span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//退出当前的查找循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k == n) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>); <span class="comment">//k==n时则没有找到输出-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="图形输出-3-3"><a href="#图形输出-3-3" class="headerlink" title="图形输出 3.3"></a>图形输出 3.3</h1><p><strong>思路</strong> ：①找出图形的规律直接输出。(可以将图形分为多个部分分别输出，这样会简单许多，不建议多重循环一步到位)</p><p>②定义一个二维字符数组，通过规律填充，然后再输出整个二维数组。</p><h2 id="【PAT-B1036】跟奥巴马一起编程"><a href="#【PAT-B1036】跟奥巴马一起编程" class="headerlink" title="【PAT B1036】跟奥巴马一起编程"></a>【PAT B1036】跟奥巴马一起编程</h2><p>美国总统奥巴马不仅呼吁所有人都学习编程，甚至以身作则编写代码，成为美国历史上首位编写计算机代码的总统。2014 年底，为庆祝“计算机科学教育周”正式启动，奥巴马编写了很简单的计算机代码：在屏幕上画一个正方形。现在你也跟他一起画吧！</p><h4 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a><strong>输入格式：</strong></h4><p>输入在一行中给出正方形边长 <em>N</em>（3≤<em>N</em>≤20）和组成正方形边的某种字符 C，间隔一个空格。</p><p> <strong>输出格式：</strong></p><p>输出由给定字符 C 画出的正方形。但是注意到行间距比列间距大，所以为了让结果看上去更像正方形，我们输出的行数实际上是列数的 50%（四舍五入取整）。</p><p> <strong>输入样例</strong></p><p>10 a</p><p> <strong>输出样例</strong></p><p>aaaaaaaaaa<br>a________a<br>a________a<br>a________a<br>aaaaaaaaaa<br>（这里的下划线代表空格）</p><hr><p><strong>分析</strong>：把图形分为<strong>顶部，底部，中间</strong>三个部分分别打印，总行数是总列数（N）的一半，当列数为<strong>偶数</strong>时只要让 <strong>N / 2 **就可以得到总的行数，当列数是</strong>奇数<strong>的时候（题目要求四舍五入）只要 **N / 2 + 1</strong> 就可以得到总行数了 ，然后让<strong>总行数减去2</strong>就可以得到中间部分的行数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//课本代码</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row, col; <span class="comment">//定义行(row)和列(column)  </span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %c"</span>,&amp;col,&amp;c);<span class="comment">//读入列数和要打印的字符</span></span><br><span class="line">    <span class="keyword">if</span>(col % <span class="number">2</span> == <span class="number">1</span>) row = col / <span class="number">2</span> + <span class="number">1</span>; <span class="comment">//计算总行数</span></span><br><span class="line">    <span class="keyword">else</span> row = col / <span class="number">2</span>;<span class="comment">//同上</span></span><br><span class="line">    <span class="comment">//👆输入部分</span></span><br><span class="line">    <span class="comment">//👇输出部分</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; col; i++) <span class="built_in">printf</span>(<span class="string">"%c"</span>,c); <span class="comment">//输出第一行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= row - <span class="number">1</span>; i++) <span class="comment">//输出第二到第row - 1行</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, c); <span class="comment">//输出中间部分的每一行的第一个符号</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col - <span class="number">2</span>; j++) <span class="built_in">printf</span>(<span class="string">" "</span>);<span class="comment">//输出中间部分每一行的空格</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c\n"</span>, c); <span class="comment">//输出中间部分的每一行的最后一个符号</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; col; i++) <span class="built_in">printf</span>(<span class="string">"%c"</span>,c);<span class="comment">//打印最后一行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🐷</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//柳婼</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; c;</span><br><span class="line">    <span class="keyword">int</span> t = N / <span class="number">2</span> + N % <span class="number">2</span>;  <span class="comment">//👍</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; c;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t - <span class="number">2</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; c;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; N - <span class="number">2</span>; k++)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N ;i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; c;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="日期处理-3-4"><a href="#日期处理-3-4" class="headerlink" title="日期处理 3.4"></a>日期处理 3.4</h1><p><strong>思路</strong> ：不断地令日期增加一天，直到两个日期相等为止。但需要处理的细节比较多，比如大月小月，闰年和非闰年的二月。</p><h2 id="【codeup-1928】-日期差值"><a href="#【codeup-1928】-日期差值" class="headerlink" title="【codeup 1928】 日期差值"></a>【codeup 1928】 日期差值</h2><p> 题目描述</p><p>有两个日期，求两个日期之间的天数，如果两个日期是连续的我们规定他们之间的天数为两天。</p><p> <strong>输入格式：</strong></p><p>有多组数据，每组数据有两行，分别表示两个日期，形式为YYYYMMDD</p><p> <strong>输出格式：</strong></p><p>每组数据输出一行，即日期差值</p><p> <strong>输入样例</strong></p><p>20130101<br>20130105</p><p> <strong>输出样例</strong></p><p>5</p><hr><p><strong>分析</strong>：①让比较小的日期的天数 <strong>d1</strong> 不断 <strong>+1</strong> 直到 *<em>d1 == d2 *</em> </p><p>②设二维int 数组 <strong>month[13] [2]  **储存每一个月份的具体天数，其中</strong>month[x] [1]** 代表闰年时，第x月有多少天，</p><p><strong>month [x] [0]</strong>代表非闰年时，第x月有多少天</p><p>③当 <strong>d</strong> 超过最大天数的时候，<strong>m + 1</strong>，当 <strong>m</strong> 超过最大月份的时候(等于13时)， <strong>y + 1</strong>; </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//课本代码 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> month[<span class="number">13</span>][<span class="number">2</span>] = </span><br><span class="line">&#123;</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">0</span>&#125;,<span class="comment">//0,0只起占位作用  </span></span><br><span class="line">    &#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">28</span>,<span class="number">29</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,</span><br><span class="line">    &#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,</span><br><span class="line">    &#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;,&#123;<span class="number">30</span>,<span class="number">30</span>&#125;,&#123;<span class="number">31</span>,<span class="number">31</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLeap</span><span class="params">(<span class="keyword">int</span> year)</span> <span class="comment">//闰年判断函数 四年一闰,百年不闰,四百年再闰；true 为润 false为平</span></span></span><br><span class="line"><span class="function">    <span class="title">return</span> <span class="params">((year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>) || year % <span class="number">400</span> == <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> time1, y1, m1, d1;</span><br><span class="line">    <span class="keyword">int</span> time2, y2, m2, d1;</span><br><span class="line">    <span class="comment">/*codeup为多点测试 我这里改为小黑框可以直接运行的代码 </span></span><br><span class="line"><span class="comment">    while(scanf("%d%d",&amp;time1,&amp;time2) != EOF) </span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">    if (time1 &gt; time2)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">    int temp = time1;</span></span><br><span class="line"><span class="comment">    time1 = time2;</span></span><br><span class="line"><span class="comment">    time2 = temp;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;time1,&amp;time2); </span><br><span class="line">    <span class="keyword">if</span>(time1 &gt; time2) <span class="comment">//如果time1大于time2进行交换</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = time1;</span><br><span class="line">        time1 = time2;</span><br><span class="line">        time2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    y1 = time1 / <span class="number">10000</span>; m1 = time1 % <span class="number">10000</span> / <span class="number">100</span>; d1 = time1 % <span class="number">100</span>; </span><br><span class="line">    y2 = time2 / <span class="number">10000</span>; m2 = time2 % <span class="number">10000</span> / <span class="number">100</span>; d2 = time2 % <span class="number">100</span>; </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>; <span class="comment">//记录最后的输出结果</span></span><br><span class="line">    <span class="comment">//👆数据输入完成</span></span><br><span class="line">    <span class="comment">//👇进行数据处理</span></span><br><span class="line">    <span class="keyword">while</span>(y1 &lt; y2 || m1 &lt; m2 || d1 &lt; d2)</span><br><span class="line">    &#123;</span><br><span class="line">        d1++; <span class="comment">//天数+1</span></span><br><span class="line">        <span class="keyword">if</span>(d1 == month[m1][isLeap(y1)] + <span class="number">1</span>) <span class="comment">//d1超过当前月份的最大天数</span></span><br><span class="line">        &#123;</span><br><span class="line">            m1++;<span class="comment">//月份加一</span></span><br><span class="line">            d1 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans++; <span class="comment">//日期差值加一</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 算法笔记 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开篇</title>
      <link href="/2019/07/23/%E5%BC%80-%E7%AF%87/"/>
      <url>/2019/07/23/%E5%BC%80-%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>​        你好！感谢你访问我的Blog！博主创建此博客的目的是为了记录从零（点五）开始学习计算机408考研的历程，距离考试还有大概一年半的时间，大家一起加油吧！耶耶耶~！</p><p>​        （如果需要联系我可以发邮件给我！<a href="mailto:dengdeng-80@163.com" target="_blank" rel="noopener">dengdeng-80@163.com</a>）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
